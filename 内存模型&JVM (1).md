***内存模型***
栈里面存放的是基本的数据类型和引用，而堆里面则是存放各种对象实例的。
 
堆与栈分开设计是为什么呢？
  * 栈存储了处理逻辑、堆存储了具体的数据，这样隔离设计更为清晰
  * 堆与栈分离，使得堆可以被多个栈共享。
  * 栈保存了上下文的信息，因此只能向上增长；而堆是动态分配

栈的大小可以通过-XSs设置，如果不足的话，会引起java.lang.StackOverflowError的异常
 
**栈区**
线程私有，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放 局部变量表、操作栈、动态链接、方法出口。
 
**堆**
存放对象实例，所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。
  * 堆得内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
  * 默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。具体的比例可以由-XX:MinHeapFreeRatio指定
  * 空余的内存大于70%时，就会减少内存，直到-Xms设置的大小。具体由-XX:MaxHeapFreeRatio指定。

因此一般都建议把这两个参数设置成一样大，可以避免JVM在不断调整大小。
 
**程序计数器**
这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。
 
**方法区**
类型信息、字段信息、方法信息、其他信息
 
总结
**名称**|**特征**|**作用**|**配置**|**异常**|
:----|:----|:----|:----|:----|
栈区|线程私有，使用一段连续的内存空间|存放局部变量表、操作栈、动态链接、方法出口|-XSs|StackOverflowError OutOfMemoryError|
堆|线程共享，生命周期与虚拟机相同|保存对象实例|-Xms -Xmx -Xmn|OutOfMemoryError|
程序计数器|线程私有、占用内存小|字节码行号|无|无|
方法区|线程共享|存储类加载信息、常量、静态变量等|-XX:PermSize -XX:MaxPermSize|OutOfMemoryError|

 
***垃圾回收***
 
1、    哪些内存需要回收？
 
2、    什么时候回收？
 
3、    如何回收？
 
**GC在什么时候会触发垃圾回收**
1、    对象没有引用
2、    作用域发生未捕获异常
3、    程序在作用域正常执行完毕
4、    程序执行了System.exit()
5、    程序发生意外终止（被杀进程等）
注意：当对象的值为null不一定代表会被标记为可回收，有可能会发生逃逸，当这个pojo重写finalize方法后，在gc回收之前会先调用一次这个方法，你只要在方法中将this指针又指向自己就可以逃逸（自救），但是finalize方法只会被执行一次。
垃圾回收器负责：
  * 分配内存
  * 保证所有正在被引用的对象还存在于内存中
  * 回收执行代码已经不再引用的对象所占的内存

 
**如何定义垃圾**
有两种方式，一种是引用计数（但是无法解决循环引用的问题）；另一种就是可达性分析。
  * **引用计数器法：**

在jdk1.2之前，使用的是引用计数器算法，即当这个类被加载到内存之后，就会产生方法区
，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用的时候，引用计数器继续+1，而当其中一个引用销毁的时候，引用计数器-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！这种算法在JDK1.2之前的版本被广泛使用，但是随着业务的发展，很快出现了一个问题
当我们的代码出现下面的情形时，该算法将无法适应
 
ObjA.obj = ObjB
 
ObjB.obj - ObjA
这样的代码会产生如下引用情形 objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。
  * **标记清除算法**

**根搜索算法**
根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。
 
目前java中可作为GC Root的对象有
    1. 虚拟机栈中引用的对象（本地变量表）
    2. 方法区中静态属性引用的对象
    3. 方法区中常量引用的对象
    4. 本地方法栈中引用的对象（Native对象）

 
算法示意图
![图片](https://images-cdn.shimo.im/YpQYSeIAU3kUYYzc/image.image/png!thumbnail)
 
       标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
 
  * **标记整理算法**

![图片](https://images-cdn.shimo.im/Ru2gPzjeoQ4oAzwt/image.image/png!thumbnail)
       标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。
 
  * **复制**

![图片](https://images-cdn.shimo.im/7hE1LkTmAD4mFxLa/image.image/png!thumbnail)
       该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。
 
  * **分代回收**

![图片](https://images-cdn.shimo.im/neimY4XgL0s0fqkA/image.image/png!thumbnail)
Hotspot VM提供的垃圾回收器是一个分代垃圾回收器（Generational GC）将内存划分为不同的阶段，也就是说，不同的生命周期的对象放置在不同的地址池中。这样的设计是基于弱年代假设（Weak Generational Hypothesis）：
1.越早分配的对象越容易失效；
2.老对象很少会引用新对象。
这种分代方式可以减少垃圾回收的停顿时间以及大范围对象的回收成本。Hotspot VM将其堆空间分为三个分代空间：
1. **年轻代**（**Young Generation**）
       1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
　　2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。
　　3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC（全收集），也就是新生代、老年代都进行回收
　　4.新生代发生的GC也叫做Minor GC（次收集），MinorGC发生频率比较高(不一定等Eden区满了才触发)
2. **年老代**（**Old Generationn**）
      1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
　　2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。
3. **持久代**（**Permanent Generation**）
       用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。
  * **adaptive算法**

       在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。
***GC（垃圾收集器）***
新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge
老年代收集器使用的收集器：Serial Old、Parallel Old、CMS
![图片](https://images-cdn.shimo.im/i8pbeOv3v6EDfSim/image.image/png!thumbnail)
 
**Serial收集器（复制算法)**
![图片](https://images-cdn.shimo.im/1i2TLBKObvcgTvst/image.image/png!thumbnail)
　　新生代单线程收集器，标记和清理都是单线程，优点是简单高效。
Serial Old收集器(标记-整理算法)
　　老年代单线程收集器，Serial收集器的老年代版本。
ParNew收集器(停止-复制算法)　
　　新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。
**Parallel Scavenge收集器(停止-复制算法)**
![图片](https://images-cdn.shimo.im/AmpfDkHJXxsv6MOr/image.image/png!thumbnail)
　　并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。
Parallel Old收集器(停止-复制算法)
　　Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先
**CMS(Concurrent Mark Sweep，并发标记清除收集器)收集器（标记-清理算法）**
 
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
 
从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：
 
初始标记（CMS initial mark）
 
并发标记（CMS concurrent mark）
 
重新标记（CMS remark）
 
并发清除（CMS concurrent sweep）
 
其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
 
由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。通过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。
![图片](https://images-cdn.shimo.im/qkoWPsB1CNwR3Mw7/image.image/png!thumbnail)
 
CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：
 
  * **CMS收集器对CPU资源非常敏感**。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/ 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。

 
  * **CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”**失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。

 
  * 还有最后一个缺点，在本节在开头说过，**CMS是一款基于“标记-清除”算法实现的收集器**，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着**收集结束时会产生大量空间碎片**。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。

 
**G1收集器**
 
G1是一款面向服务端应用的垃圾收集器。G1具备如下特点：
 
1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
 
2、分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。
 
3、空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
 
4、可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，
 
5、G1运作步骤：
 
1、初始标记；2、并发标记；3、最终标记；4、筛选回收
 
上面几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
       
![图片](https://images-cdn.shimo.im/qWFCPMFzEcUr7PGo/image.image/png!thumbnail)
 
