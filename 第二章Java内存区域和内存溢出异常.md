# 2.2运行时数据区
2.2.1程序计数器pc（线程私有）
1. 指向当前线程正在执行的字节码指令的地址，行号。
  1. 字节码解释器就是通过改变它的值来选取下一条需要执行的字节码指令，
    1. 分支、循环、跳转、异常处理、等基础功能都需要依赖这个计数器实现。
2. 如果线程执行Java方法，这个计数器记录的是正在执行的字节码指令的地址：如果线程执行的是Native方法 ，这个计数器值则为空（UNdefined）
3. 唯一一个不会发生OutOfMemoryError的区域


2.2.2Java虚拟机栈（线程私有）
1. 存储当前线程运行方法是所需的 数据、指令、返回地址。
2. 每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
3. 两种异常：
    1. 1.如果线程请求的栈深度超过虚拟机所允许的深度，将会抛出StackOverflowError异常
    2. 2.如果虚拟机栈扩展是无法申请到足够的内存就会抛出OutOfMemoryError异常。


---

2.2.3本地方法栈（线程私有）
1. 功能与本地方法相似，
2. 区别：
  1. Java虚拟机栈为Java方法提供服务，
  2. 本地方法栈为本地方法提供服务、

3.两种异常：
  1. 如果线程请求的栈深度超过虚拟机所允许的深度，将会抛出StackOverflowError异常
  2. 如果虚拟机栈扩展是无法申请到足够的内存就会抛出OutOfMemoryError异常。


---
2.2.4Java堆（线程共享）
1. 对象实例和数组都在堆上分配（也可以栈上分配）
2. 字符串常量池存放于堆中（JDK1.7放入）
3. 堆最大容量：-Xmx   、最小容量：Xms控制
4. 如果堆中没有内存来完成实例分配，并且堆无法扩展时，将会抛出OutOfMemoryError


---
2.2.5方法区（线程共享）
用于存放已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据
也叫永久带1.8改为元数据区（meta space）可动态扩展

内存回收的目标主要是  针对常量池的回收和对类型的卸载（条件苛刻   容易导致内存泄漏）
内存泄露
```
内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。
那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景
```


